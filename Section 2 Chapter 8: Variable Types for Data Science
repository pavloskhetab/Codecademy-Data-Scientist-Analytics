Assessing Variable Types
“It all began with a variable”, the storyteller began.

Just kidding, no one starts their stories that way, even though variables are where all data stories begin.

Variables define datasets. They are the characteristics or attributes that we evaluate during data collection. 
There are two ways to do that evaluation: we can measure or we can categorize.

How we evaluate determines what kind of variable we have. Since there are only two ways to get data, 
there are only two types of variables: numerical and categorical.

A box labeled "Variables" points to two boxes below labeled "Categorical" and "Quantitative"

Every observation (the individuals or objects we are collecting data about) is classified according to its 
characteristics. In “flat” file formats (like tables, csvs, or DataFrames), the observations are the rows, 
the variables are the columns, and the values are at the intersection.

We’ll go deeper into categorical and numerical variables in the following exercises.

Typically, the best way to understand your data is to look at a sample of it.

In the example dataset about cereal below, we can look at the first few rows with the .head() 
method to get an idea of the variable types that we have.

print(cereal.head())

id	name	mfr	type	fiber	rating	shelf	vitamins	coupons	price
0	22341	100% Bran…	Nestle	C	10.0	68.40	top	25	4	3.46
1	22791	100% Natur…	Quaker Oats	C	2.0	33.98	top	0	1	3.36
2	98141	All-Bran…	Kelloggs	C	9.0	59.43	top	25	4	2.07
3	20001	All-Bran w…	Kelloggs	C	14.0	93.70	top	25	3	3.57
4	67121	Almond Del…	Ralston P..	C	1.0	34.38	top	25	1	5.21

There are several types of variables. For example:

The price column describes how much the cereal costs. We don’t know if that’s how much 
the consumer pays or the grocer pays, but we can be fairly sure that it’s a numerical variable.

In the mfr column, there are labels like Nestle, Quaker Oats, and Kelloggs, which seem like brands. 
Since brands are categories, mfr is most likely a categorical variable.

The id column also has numbers, but we can assume that since it’s the id, it’s not actually representing a value. 
It’s probably the label for the observation. Since it’s a label, even though it’s a number, 
id is a categorical variable.

If we were downloading this from a data repository, we would expect a data dictionary to define these 
variables and validate (or invalidate) our assumptions.

It is still important to inspect our dataset because it gives us a better understanding of the data 
that we are working with and the kinds of operations that will be possible.

Let’s practice inspecting a dataset to identify its variable types.

This dataset is a modified version of this Netflix data. The est_budget (USD) and cast_count variables 
were created for illustration purposes.

Code:
import codecademylib3

# Import pandas with alias
import pandas as pd

# Import dataset as a Pandas dataframe
movies = pd.read_csv("netflix_movies.csv", index_col=0)

# View the first five rows of the dataframe
print(movies.head())

# Set the correct value for rating_variable_type
rating_variable_type = 'categorical'
print(rating_variable_type)



Categorical Variables
Without getting too philosophical about it, “your mind is a categorization machine” - HBR. 
We move through the world by categorizing things into various groups: safe/unsafe, best/worst, on/off. 
These categorizations help us process information. They also create major problems for us when we over-categorize, 
and can lead to bias and unfair assumptions.

However, we still do it, and regardless of the dangers, categorization helps us transform 
the world around us into data. (Being aware of the dangers is a crucial part of data analysis, 
but outside the scope of this lesson.)

Categorical variables come in 3 types:

Nominal variables, which describe something,
Ordinal variables, which have an inherent ranking, and
Binary variables, which have only two possible variations.
one box with 'Nominal variables' written in it and 3 boxes blow it with 'Nominal', 'Ordinal', 
and 'Binary' below, illustrating the relationship between each of these types of variables and nominal variables.

Let’s look at each one separately

Nominal Variables
When we want to describe something about the world, we need a nominal variable. 
Nominal variables are usually words (i.e., red, yellow, blue or hot, cold), 
but they can also be numbers (i.e., zip codes or user id’s).

Often, nominal variables describe something with a lot of variation. 
It can be hard to capture all of that variation, so an ‘Other’ category is often necessary. 
For example, in the case of color, we could have a lot of different labels, 
but might still need an ‘Other’ category to capture anything we missed.

Ordinal variables
When our categories have an inherent order, we need an ordinal variable. 
Ordinal variables are usually described by numbers like 1st, 2nd, 3rd. 
Places in a race, grades in school, and the scales in survey responses (Likert Scales) are ordinal variables.

Ordinal variables can be a little tricky because even though they are numbers, 
it doesn’t make sense to do math on them. For example, let’s say an Olympian won a Gold medal (1st place) 
and a Bronze medal (3rd place). We wouldn’t say that they averaged Silver medals (2nd place).

Though there is some debate about whether Likert scales should be treated like intervals or ordinal categories, 
most statisticians agree that they are ordinal categories and therefore should not be summarized numerically.

Binary variables
When there are only two logically possible variations, we need a binary variable. 
Binary variables are things like on/off, yes/no, and TRUE/FALSE. If there is any possibility of a third option, 
it is not a binary variable.

Let’s take a look at our cereal dataset.

print(cereal.head())

id	name	mfr	type	fiber	rating	shelf	vitamins	coupons	price
0	22341	100% Bran…	Nestle	C	10.0	68.40	top	25	4	3.46
1	22791	100% Natur…	Quaker Oats	C	2.0	33.98	top	0	1	3.36
2	98141	All-Bran…	Kelloggs	C	9.0	59.43	top	25	4	2.07
3	20001	All-Bran w…	Kelloggs	C	14.0	93.70	top	25	3	3.57
4	67121	Almond Del…	Ralston P..	C	1.0	34.38	top	25	1	5.21

There are some obvious categorical variables: The name of the product, the mfr (manufacturer), 
and the shelf are all nominal categorical variables. We know this because they are written in descriptive 
words or letters.

A little less obvious is the type field. They are all ‘C’, which could be a ranking (A, B, C, and 
therefore an ordinal variable) or it could be a description and therefore a nominal variable. 
We would have to return to the data dictionary to find out for certain.

The id field may also cause confusion. It’s a number, but it’s not a count or a measurement. 
Rather, ‘id’ is a categorical variable since it is describing each observation in the same way that the name is.

Let’s go over our Netflix dataset to get a little more practice working with categorical variables.

Code:
import codecademylib3

# Import pandas with alias
import pandas as pd

# Import dataset as a Pandas dataframe
movies = pd.read_csv("netflix_movies.csv")

# View the first five rows of the dataframe
print(movies.head())

# Print the unique values in the country column
print(movies.country.unique())

# Set the correct value for country_variable_type
country_variable_type = 'nominal'



Quantitative Variables
“One accurate measurement is worth a thousand expert opinions”

– Grace Hopper

Numerical variables are created two ways: through measurement and counting. 
While measurement is a matter of philosophical debate, counting is pretty straightforward. 
The result is continuous and discrete variables.

one box labeled 'Numerical' with two boxes below it labeled 'Continous' and 'Discrete' 
to represent the relationship between the three terms

Continuous variables come from measurements. For a variable to be continuous, 
there must be infinitely smaller units of measurement between one unit and the next unit. 
Continuous variables can be represented by decimal places (but because of rounding, 
sometimes they are whole numbers). Length, time, and temperature are all good examples of 
continuous variables because they all increase continuously.

Discrete variables come from counting. For a variable to be discrete, 
there must be gaps between the smallest possible units. People, cars, 
and dogs are all good examples of discrete variables.

Some variables depend on context to determine if they are continuous or discrete. 
Money and time can both be measured continuously or discretely.

For money, all currencies have a smallest-possible-unit (i.e., the cent in USD) 
and are therefore discrete. However, banks and other institutions sometimes measure money 
in fractions of a cent, treating it like a continuous variable.

It is therefore always essential to understand how your data was created in order 
to represent it appropriately.

Let’s take a look at the cereal dataset again.

id	name	mfr	type	fiber	rating	shelf	vitamins	coupons	price
0	22341	100% Bran…	Nestle	C	10.0	68.40	top	25	4	3.46
1	22791	100% Natur…	Quaker Oats	C	2.0	33.98	top	0	1	3.36
2	98141	All-Bran…	Kelloggs	C	9.0	59.43	top	25	4	2.07
3	20001	All-Bran w…	Kelloggs	C	14.0	93.70	top	25	3	3.57
4	67121	Almond Del…	Ralston P..	C	1.0	34.38	top	25	1	5.21

There are five numerical variables: fiber, rating, vitamins, coupons, and price.

Without looking at the data dictionary, we can make some guesses about 
what kind of numerical variables they are:

Fiber, rating, and price all have decimal places. That’s our first clue that they might be continuous. 
Based on our limited knowledge, we might guess that fiber and rating are both continuous measurements 
that could have more decimal places, and price is discrete because there’s nothing smaller than a cent.

Vitamins and coupons do not have decimal places. Vitamins and coupons both seem 
like good candidates to be counts and therefore discrete. The answers to “how many vitamins” 
and “how many coupons” would both be whole numbers. (We already said that ID 
is categorical in the last exercise)

We would be more confident in our answers if we were able to inspect the documentation. 
But sometimes documentation isn’t available and you have to take your best guess.

Let’s try it out on our Netflix data.

Code:
import codecademylib3

# Import pandas with alias
import pandas as pd

# Import dataset as a Pandas dataframe
movies = pd.read_csv("netflix_movies.csv")

# View the first five rows of the dataframe
print(movies.head())

# Set the correct value for release_year_variable_type
release_year_variable_type = 'discrete'
print(release_year_variable_type)

# Set the correct value for duration_variable_type
cast_count_variable_type = 'discrete'
print(cast_count_variable_type)



Changing Numerical Variable Data Types
Congratulations - being able to identify variable types is the first (and most important) 
step towards working with data. The next is understanding how Python (and the pandas library) store your data.

When you read a data file (such as a csv) with pandas, data types are assigned to each column. 
Pandas does its best to predict what kind of data type each variable should contain. 
For example, if a column contains only integer values, it will be stored as an int32 or int64. 
This usually works, but problems can arise for our analysis later on when there’s a mismatch between 
the real-world variable type and the data type pandas assigns.

With numerical variables, pandas expects any column that has decimal values to be a float and 
anything without decimal values to be an integer. If any non-numeric characters appear in the column, 
pandas will treat it as an object.

It’s possible to determine the data types of the columns in your DataFrame with the .dtypes attribute.

For example, in our cereal dataset, Pandas returned the following list:

print(cereal.dtypes)

name	object
id	int64
name	object
mfr	object
type	object
fiber	float64
rating	float64
shelf	object
vitamins	int64
coupons	int64
price	float64
dtype: object	

Best practices for data storage say that we should match the data type of the column 
with its real-world variable type. Therefore:

Continuous (numerical) variables should usually be stored as 
the float data type because they allow us to store decimal values.

Discrete (numerical) variables should be stored as the int datatype 
to represent mathematically that they are discrete.

(note that the difference between int32/int64 and float32/float64 
does not concern us here – it is an issue for much larger numbers)

Using float and int to store quantitative variables is important 
so that you can later perform numerical operations on those values. 
It also helps indicate what the variables refer to in the real world. 
Keeping them separate helps ensure that we perform the right calculations 
and get the right results. For example,

If a variable appears with the wrong data type, we can change it with the .astype() function.

cereal['id'] = cereal['id'].astype("string")

print(cereal.dtypes)

name	object
id	string
name	object
mfr	object
type	object
fiber	float64
rating	float64
shelf	object
vitamins	int64
coupons	int64
price	float64
dtype: object	
The .astype() function can be used to convert between a numerical data types, including:

int32 int64
float32 float64
object
string
bool

However, some data types require all values to be filled in. 
For example, you cannot convert between a float and an int if there are any null values.

Let’s go ahead and try to clean up our Netflix data.

Code:
import codecademylib3

# Import pandas with alias
import pandas as pd

# Import dataset as a Pandas dataframe
movies = pd.read_csv("netflix_movies.csv")

# View the first five rows of the dataframe
print(movies.head())

# Print the data types
# print(movies.dtypes)

# Fill in the missing cast_count values with 0
movies['cast_count'].fillna(0, inplace = True)

# Change the type of the cast_count column
movies['cast_count'] = movies.cast_count.astype("int64")

# Check the data types of the columns again. 
print(movies.dtypes)



Changing Categorical Variable Data Types
Now let’s focus on Categorical variables and make sure they are in the correct format. 
Let’s take another look at the cereal dataset to assess the data types of our categorical variables.

print(cereal.dtypes)

name	object
id	int64
name	object
mfr	object
type	object
fiber	float64
rating	float64
shelf	object
vitamins	int64
coupons	int64
price	float64
dtype: object	
Just like with numerical variables, best practices for categorical data storage 
say that we should match the data type of the column with its real-world variable type. 
However, the types are a little more nuanced:

Nominal variables are often represented by the object data type. 
Columns in the object data type can contain any combination of values, including strings, 
integers, booleans, etc. This means that string operations like .lower() are not possible on object columns.

Nominal variables are also represented by the string data type. However, 
Pandas usually guesses object rather than string, so if you want a column to be a string, 
you will likely have to explicitly tell pandas to make it a string. 
This is most important if you want to do string manipulations on a column like .lower().

Ordinal variables should be represented as objects, but pandas often guesses int since 
they are often encoded as whole numbers.

Binary variables can be represented as bool, but pandas often guesses int or object data types.

We have a lot to change in our cereal dataset, so let’s go through them one by one.

We already learned about the .astype() function and can be used to convert into the following 
categorical data types:

object
string
bool
We’ll start by looking at the data types again.

print(cereal.dtypes)

name	object
id	int64
name	object
mfr	object
type	object
fiber	float64
rating	float64
shelf	object
vitamins	int64
coupons	int64
price	float64
dtype: object	

id should be an object since it’s a nominal variable that is not a string.
name and mfr should be strings since they are words and we may want to lowercase, 
uppercase, or otherwise transform them with string methods.
shelf and type can stay as objects since they are codes 
(though it would be just as valid to make them into strings)
cereal['id'] = cereal['id'].astype("object")
cereal['name'] = cereal['name'].astype("string")
cereal['mfr'] = cereal['mfr'].astype("string")

name	object
id	object
name	string
mfr	string
type	object
fiber	float64
rating	float64
shelf	object
vitamins	int64
coupons	int64
price	float64
dtype: object	
Now it’s time for you to try it on the Netflix data. 
Be sure to take into account how the data is recorded and what you might want to do with each variable.

Code:
